<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Span-based multi-granularity word segment results display</title>
    <!-- 引入Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <!-- 引入ECharts JS -->
    <script src="http://cdn.jsdelivr.net/npm/echarts@5.3.2/dist/echarts.min.js"></script>
    <style>
        #treeChart {
            width: 100%;
            height: 600px;
        }
        #maxi{
            display: flex; /* 启用 Flexbox */
            flex-direction: column; /* 子元素垂直堆叠 */
            width: 100%;
        }
        .result-box {
            background-color: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 0.25rem;
            padding: 1px;
            padding-top: 10px;
            margin-bottom: 1px;
            width: 100%;
            /*width: calc(50% - 10px); !* 考虑到padding和margin的影响 *!*/
        }
        .result-box h5{
            text-align: center; /* 居中文本 */
        }
        /*.result-box {*/
        /*    background-color: #f8f9fa;*/
        /*    border: 1px solid #dee2e6;*/
        /*    border-radius: 0.25rem;*/
        /*    padding: 10px;*/
        /*    margin-bottom: 15px;*/
        /*}*/
        /* 定义渐变背景色 */
    /* 定义渐变背景色 */
        /* 基础样式 */
        .gradient-btn {
            border: none;
            color: white;
            padding: 10px 20px;
            text-align: center;
            text-decoration: none;
            display: inline-block;
            font-size: 16px;
            margin: 4px 2px;
            cursor: pointer;
            border-radius: 4px; /* 可选：添加圆角 */
        }

        /* 定义不同级别的颜色 */
        .gradient-btn-0 { background: linear-gradient(to right, #ffffff, #f0f0f0); }
        .gradient-btn-1 { background: linear-gradient(to right, #f0f0f0, #e0e0e0); }
        .gradient-btn-2 { background: linear-gradient(to right, #e0e0e0, #d0d0d0); }
        .gradient-btn-3 { background: linear-gradient(to right, #d0d0d0, #c0c0c0); }
        .gradient-btn-4 { background: linear-gradient(to right, #c0c0c0, #b3b3b3); }
        .gradient-btn-5 { background: linear-gradient(to right, #b3b3b3, #a6a6a6); }
        .gradient-btn-6 { background: linear-gradient(to right, #a6a6a6, #999999); }
        .gradient-btn-7 { background: linear-gradient(to right, #999999, #8c8c8c); }
        .gradient-btn-8 { background: linear-gradient(to right, #8c8c8c, #808080); }
        .gradient-btn-9 { background: linear-gradient(to right, #808080, #808080); }

        .custom-button {
            --bs-btn-bg: #6c757d; /* 主背景颜色 */
            --bs-btn-border-color: #6c757d; /* 边框颜色 */
            --bs-btn-hover-bg: #545b64; /* 悬停时的背景颜色 */
            --bs-btn-hover-border-color: #545b64; /* 悬停时的边框颜色 */
            --bs-btn-focus-shadow-rgb: 108, 117, 125; /* 焦点状态下的阴影颜色 */
            --bs-btn-box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.15), 0 1px 1px rgba(0, 0, 0, 0.075); /* 阴影 */
            --bs-btn-focus-box-shadow: 0 0 0 0.25rem rgba(var(--bs-btn-focus-shadow-rgb), .5); /* 焦点状态下的阴影 */
            --bs-btn-disabled-opacity: 0.65; /* 禁用状态下的透明度 */

            color: #fff; /* 文字颜色 */
            background-color: var(--bs-btn-bg);
            border-color: var(--bs-btn-border-color);
            box-shadow: var(--bs-btn-box-shadow);
            transition: all 0.2s ease-in-out;

            &:hover {
                background-color: var(--bs-btn-hover-bg);
                border-color: var(--bs-btn-hover-border-color);
                box-shadow: var(--bs-btn-box-shadow);
            }

            &:focus {
                box-shadow: var(--bs-btn-focus-box-shadow);
            }

            &:active {
                background-color: #545b64; /* 激活状态下的背景颜色 */
                border-color: #545b64; /* 激活状态下的边框颜色 */
                box-shadow: var(--bs-btn-box-shadow);
            }

            &:disabled, &[disabled] {
                opacity: var(--bs-btn-disabled-opacity);
                pointer-events: none;
            }
        }

        .custom-input {
            background-color: #fff; /* 背景颜色为白色 */
            color: #495057; /* 文字颜色 */
            border-color: #dee2e6; /* 边框颜色 */
            width: 70%;

            &:focus {
                border-color: #aaa; /* 获取焦点时的边框颜色 */
                box-shadow: 0 0 0 0.25rem rgba(155, 153, 153, 0.2); /* 获取焦点时的四周灰色阴影 */
            }
        }

    </style>
</head>
<body>
    <!-- 容器 -->
    <div class="container mt-5">
        <!-- 输入区域 -->
        <div class="row">
            <div class="col-md-6 offset-md-3">
                <div class="input-group mb-3">
                    <input type="text" class="custom-input" id="inputText" style="background-color: #f8f9fa; color: #495057; border-color: #dee2e6;" placeholder="Please enter the text to be segmented.">
<!--                    <input type="text" class="form-control" id="inputText" placeholder="Please enter the text to be segment.">-->
                    <button class="btn custom-button" type="button" id="segmentBtn">Word Segment</button>
                </div>
            </div>
        </div>
        <!-- 图表区域 -->
        <div class="row mt-4">
            <div class="col-md-10 offset-md-1">
                <div id="treeChart"></div>
            </div>
        </div>
        <!-- 结果展示区域 -->
        <div class="row mt-4" id="maxi" style="align-content: center">
            <div class="col-md-10">
                <div class="result-box">
                    <h5>CTB guideline</h5>
                    <p id="result_ctb"></p>
                </div>
            </div>
            <div class="col-md-10">
                <div class="result-box">
                    <h5>MSR guideline</h5>
                    <p id="result_msr"></p>
                </div>
            </div>
            <div class="col-md-10">
                <div class="result-box">
                    <h5>PKU guideline</h5>
                    <p id="result_pku"></p>
                </div>
            </div>
            <div class="col-md-10">
                <div class="result-box">
                    <h5>Candidate words</h5>
                    <p id="candidate Words"></p>
                </div>
            </div>
        </div>
    </div>

    <!-- DOM 加载完成后执行脚本 -->
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // 获取DOM元素
            const inputText = document.getElementById('inputText');
            const segmentBtn = document.getElementById('segmentBtn');
            const chartDom = document.getElementById('treeChart');
            const myChart = echarts.init(chartDom); // 初始化 ECharts 实例
            const result_ctb = document.getElementById('result_ctb');
            const result_msr = document.getElementById('result_msr');
            const result_pku = document.getElementById('result_pku');

            // 分词按钮点击事件
            segmentBtn.addEventListener('click', function() {
                const text = inputText.value.trim();
                if (text) { // 如果输入文本非空
                    fetchSegmentation(text); // 发起分词请求
                } else {
                    alert('Please enter the text to be tokenized.'); // 提示输入文本
                }
            });

            // 向服务器发送分词请求
            function fetchSegmentation(text) {
                fetch('http://127.0.0.1:5000/segment', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ 'sentence': text }), // 发送文本数据
                })
                .then(response => response.json()) // 解析JSON响应
                .then(data => {
                    // console.log(data);
                    renderTree(data.mws_res); // 渲染树状图
                    // updateResults(text, data); // 更新结果显示
					updateResults(data); // 更新结果显示
                })
                .catch((error) => {
                    console.error('Error:', error); // 打印错误信息
                    // alert('An error occurred while retrieving the segmentation results.'); // 显示错误提示
                });
            }

            // 根据置信度计算颜色
            function getColor(value) {
                const hue = (1 - value) * 240; // 色相值从蓝色到红色变化
                return `hsl(${hue}, 100%, 50%)`; // 返回颜色字符串
            }

            // 渲染树状图
            function renderTree(data) {
                const option = {
                    tooltip: {
                        trigger: 'item', // 悬停在项目上显示提示
                        triggerOn: 'mousemove' // 当鼠标移动到项目上时触发
                    }, series: [
                        {
                            type: 'tree', // 图表类型为树状图
                            data: [data], // 数据源
                            top: '10%', // 上方留白
                            left: '7%', // 左侧留白
                            bottom: '15%', // 下方留白
                            right: '7%', // 右侧留白
                            symbolSize: 0, // 节点符号大小
                            orient: 'vertical', // 垂直方向布局
                            label: {
                                position: 'top', // 标签位置
                                rotate: 0, // 标签旋转角度
                                verticalAlign: 'middle', // 垂直对齐方式
                                align: 'center', // 水平对齐方式
                                fontSize: 16, // 字体大小
                                formatter: function(params) { // 格式化标签内容
                                    if (params.data.value !== null) {
                                        // return `{word|${params.name}}\n{value|${params.data.value.toFixed(2)}}`;
                                        return `{word|${params.name}}\n{value|${params.data.value.toFixed(2)}}`;
                                    }
                                    return `{word|${params.name}}`;
                                },
                                rich: { // 富文本样式
                                    word: {
                                        fontSize: 16,
                                        color:'black',
                                        // backgroundColor: '#ccc8c8',
                                        backgroundColor: '#ffffff',
                                        // backgroundColor: function(params) {
                                        //     if (params.data.name !== 'S' && params.data.name !== 'W' && params.data.name !== 'C') {
                                        //         // 叶子节点背景色
                                        //         return '#f10909';
                                        //     } else {
                                        //         // 非叶子节点背景色
                                        //         return '#a19f9f';
                                        //     }
                                        // },
                                        padding: [5, 10],
                                        borderRadius: 5
                                    },
                                    value: {
                                        color: '#a19f9f',
                                        fontSize: 14
                                    }
                                }
                            },
                            leaves: { // 叶子节点的标签配置
                                label: {
                                    position: 'bottom',
                                    rotate: 0,
                                    verticalAlign: 'middle',
                                    align: 'center',
                                    // backgroundColor: '#ffffff'
                                }
                            },
                            itemStyle: { // 节点样式
                                color: function(params) {
                                    if (params.data.children === []){
                                        return '#ffffff'
                                    }else{
                                        return '#555'; // 非叶子节点的颜色
                                    }
                                }
                            },
                            emphasis: { // 高亮配置
                                focus: 'descendant' // 高亮焦点及其后代
                            },
                            expandAndCollapse: true, // 允许展开和折叠
                            animationDuration: 550, // 动画持续时间
                            animationDurationUpdate: 750, // 更新动画持续时间
                            initialTreeDepth: 10 // 初始树深度
                        }
                    ]
                };
                console.log(option);
                myChart.setOption(option); // 应用图表配置
            }

            // 更新结果显示
            // function updateResults(text, data) {
            //     const wordCount = countWords(data); // 计算分词数量
            //     const avgConfidence = calculateAverageConfidence(data); // 计算平均置信度
            //     // result_ctb.textContent = `输入文本的长度：${text.length} 字符`; // 显示文本长度
            //     // result_msr.textContent = `分词数量：${wordCount} 个`; // 显示分词数量
            //     // result_pku.textContent = `平均置信度：${avgConfidence.toFixed(2)}`; // 显示平均置信度
            //     result_ctb.textContent='';
            // }
			function updateResults(jsonData) {
				console.log(jsonData)
			    document.getElementById('result_ctb').innerHTML = createButtons(jsonData.ctb_res);
			    document.getElementById('result_msr').innerHTML = createButtons(jsonData.msr_res);
			    document.getElementById('result_pku').innerHTML = createButtons(jsonData.pku_res);
                document.getElementById('candiate_words').innerHTML = createButtons(jsonData.candiate_words);
			}
            // 计算分词数量
            function countWords(node) {
                if (!node.children || node.children.length === 0) {
                    return 1; // 如果是叶子节点返回1
                }
                return node.children.reduce((sum, child) => sum + countWords(child), 0); // 递归计算所有子节点
            }

            function createButtons(data) {
			    let html = '';
			        for (const [key, value] of Object.entries(data)) {
			            let btnClass = '';
                        if (value < 0.1) {
                            btnClass = 'gradient-btn gradient-btn-0';
                        } else if (value >= 0.1 && value < 0.2) {
                            btnClass = 'gradient-btn gradient-btn-1';
                        } else if (value >= 0.2 && value < 0.3) {
                            btnClass = 'gradient-btn gradient-btn-2';
                        } else if (value >= 0.3 && value < 0.4) {
                            btnClass = 'gradient-btn gradient-btn-3';
                        } else if (value >= 0.4 && value < 0.5) {
                            btnClass = 'gradient-btn gradient-btn-4';
                        } else if (value >= 0.5 && value < 0.6) {
                            btnClass = 'gradient-btn gradient-btn-5';
                        } else if (value >= 0.6 && value < 0.7) {
                            btnClass = 'gradient-btn gradient-btn-6';
                        } else if (value >= 0.7 && value < 0.8) {
                            btnClass = 'gradient-btn gradient-btn-7';
                        } else if (value >= 0.8 && value < 0.9) {
                            btnClass = 'gradient-btn gradient-btn-8';
                        } else if (value >= 0.9 && value <= 1.0) {
                            btnClass = 'gradient-btn gradient-btn-9';
                        }

			            html += `
			                <div class="btn-group" role="group">
                            <button class="${btnClass}" style="width: 100px; height: 30px; font-size: 15px; font-family: Arial, sans-serif; color: #000000;">${key}</button>
                            <button class="${btnClass}" style="width: 100px; height: 30px; font-size: 15px; font-family: Arial, sans-serif; color: #000000; opacity: 0.5;">${value.toFixed(2)}</button>
                        </div>
			            `;
			        }
			        return html;
			}

            // 计算平均置信度
            function calculateAverageConfidence(node) {
                let sum = 0;
                let count = 0;

                // 递归遍历树结构
                function traverse(n) {
                    if (n.value !== null) {
                        sum += n.value;
                        count++;
                    }
                    if (n.children) {
                        n.children.forEach(traverse);
                    }
                }

                traverse(node); // 开始遍历
                return count > 0 ? sum / count : 0; // 计算平均值
            }
        });
    </script>
</body>
</html>